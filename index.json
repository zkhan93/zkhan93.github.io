[{"content":"In one of the online coding interviews I was given a problem to create a snake game we all played in old days. The problem statement was something like this given the moves you have to determine after how many moves the snake will eat himself. I was able to solve the problem, but as I was solving it I was thinking \"can I can give this code a little more life with javascript\".  So here I am, this post is an attempt to give life to that algo ðŸ˜Š  {{game_state}} Score: {{points - 1}}        ","permalink":"https://zkhan.in/posts/snake-game/","summary":"In one of the online coding interviews I was given a problem to create a snake game we all played in old days. The problem statement was something like this given the moves you have to determine after how many moves the snake will eat himself. I was able to solve the problem, but as I was solving it I was thinking \"can I can give this code a little more life with javascript\"","title":"Snake Game"},{"content":" The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. for more detail check Wikipedia  In short, the game is a 2D grid that has the following rules Game Rules  Any live cell with fewer than two live neighbours dies, as if by underpopulation. Any live cell with two or three live neighbours lives on to the next generation. Any live cell with more than three live neighbours dies, as if by overpopulation. Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.  I just wanted to implement this game for fun ðŸ˜Š , Marking of initial alive cells is little tricky on touchscreen devices.\n Live cell color:  Preview:    Mark cells Unmark cells {{start_stop_btn_txt}} reset  Iteration: {{iteration}}        var app = new Vue({ el: '#app', data: { alive_color: '#FFFFFF', iteration: 0, running: false, mark: false, mousedown: false, grid: [], cell_size: 10, column: 40, }, computed: { row(){ return 40 }, row_style() { return {'height': this.cell_size + 'px'} }, mark_btn_color() { return this.mark ? 'green' : 'white' }, unmark_btn_color() { return this.mark ? 'white' : 'green' }, start_stop_btn_txt(){ return this.running ? \"Stop\" : \"Start\"; } }, created(){ this.init_grid() window.addEventListener(\"resize\", this.calculate_columns); }, destroyed() { window.removeEventListener(\"resize\", this.calculate_columns); }, mounted(){ this.calculate_columns() }, methods: { calculate_columns(){ this.column = parseInt((this.$refs.box.clientWidth/this.cell_size) - 1) console.log(this.column) }, init_grid(){ this.grid = []; for (var i = 0; i {if (val) alive_neighbours += 1}) if(curr_val){ if (alive_neighbours 3) return false return true } else{ if (alive_neighbours == 3) return true return false } }, get_neighbours(i, j){ var values = [] var rowi = [i, i+1, i-1] var colj = [j, j+1, j-1] rowi.forEach(a = { colj.forEach( b={ if ((a = 0) \u0026\u0026 (b = 0) \u0026\u0026 !(a == i \u0026\u0026 b == j) ){values.push(this.grid[a][b])} }) }) return values } } })   .cell{ border: 1px solid grey; display: inline-block; } .cell:hover { background-color: grey; } .box{ height: 403px; width: 100%; margin: auto; } .row{ width: 100%; display: flex; margin: 0; padding: 0; justify-content: center; } .container{ align-items: center; } .btn{ padding: 3px 5px; border-radius: 5px; margin: 5px; font-size: 0.7em; text-transform: uppercase; font-weight: bold; color: white; background-color: grey; } .btn.active{ background-color: royalblue; } .btn:hover{ background-color: lightskyblue !important; color: white; } .green{ background-color: seagreen; } .red{ background-color: red; } ","permalink":"https://zkhan.in/posts/game-of-life/","summary":"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. for more detail check Wikipedia  In short, the game is a 2D grid that has the following rules Game Rules  Any live cell with fewer than two live neighbours dies, as if by underpopulation. Any live cell with two or three live neighbours lives on to the next generation.","title":"Game of Life"},{"content":"We are going to serialize a binary tree to an array, A binary tree is a tree data structure. Each node can have 0-2 children(s).\nvisualization of a binary tree\n 2 / \\ / \\ / \\ 1 3 / \\ / \\ 0 7 9 1 / / \\ / \\ 2 1 0 8 8 Representation of a Node A node should contain the data(value) and reference to child nodes. A simple class like Node below will work for us.\nclass Node: data = None left = None right = None def __init__(self, data): self.data = data Height of a Binary Tree Height is the max level of nodes in a tree. In the example above tree\u0026rsquo;s height is 4. Given a reference to a tree\u0026rsquo;s root node, we can find its height as below\ndef get_height(root): if root is None: return 0 stack = [(1, root)] max_level = 1 while stack: level, node = stack.pop() if level \u0026gt; max_level: max_level = level if node.left: stack.append((level + 1, node.left)) if node.right: stack.append((level + 1, node.right)) return max_level We use a stack to traverse the tree. Each entry in the stack contains the node\u0026rsquo;s level and the node itself. As we traverse the tree we keep track of the highest level seen so far. We add 1 to the current level while adding children of the current node to a stack. In the end we will have the tree\u0026rsquo;s height in max level.\nAn interesting thing to note here is we can also use Queue to traverse the tree, however, a sibling will be visited earlier than a child, hence making it a BFS (Breadth-First Search) instead of a DFS (Depth-First Search) We have to traverse the complete tree, hence, the time complexity of finding out the height of the tree will be O(n)\nSerialization We can represent a binary tree with an array, where left and right children of a node at index n can be placed at (n * 2) + 1 and (n * 2) + 2 index respectively.\nTo represent a Binary Tree we would need an array to hold all the nodes. Our array length is dependent on the tree\u0026rsquo;s height and since a binary tree might have some missing subtree, but the array has to have space for all items as if the tree is a complete binary tree. The length of this array will be 2**h - 1, h being the tree\u0026rsquo;s height.\nOnce we have size of array finalized, we can traverse the tree to fill our array.\ndef serialize(root): h = get_height(root) arr = [None] * ((2**h) - 1) stack = [(0, root)] while stack: index, node = stack.pop() arr[index] = node.data if node.left: stack.append((index*2 + 1, node.left)) if node.right: stack.append((index*2 + 2, node.right)) return arr Our stack will contain tuples of 2 items, a node with its index. We start with a stack like [(0, root)]. In one iteration, we pop one item from the stack to get node and index and assign node\u0026rsquo;s data to arr[index], after that we place children of the node to the top of stack.\nDe-Serialization we should be able to create the tree back from the array we got above.\ndef deserialize(arr): nodes = [None] * len(arr) for index, data in enumerate(arr): if data: node = nodes[index] or Node(data) left_index = index * 2 + 1 right_index = index * 2 + 2 if left_index \u0026lt; len(arr) and arr[left_index]: node.left = Node(arr[left_index]) if right_index \u0026lt; len(arr) and arr[right_index]: node.right = Node(arr[right_index]) nodes[index] = node if right_index == len(arr): break return nodes[0] if nodes else None we start by iterating through the array in each iteration we create a Node object with the current value and check if child positions do not exceed the array length then initialize those child nodes and link them to parent.\nand with that we were able to serialize and deserialize the tree by calculating its height if not given then traversing through the tree once.\n","permalink":"https://zkhan.in/posts/serializing-deserializing-binary-tree/","summary":"We are going to serialize a binary tree to an array, A binary tree is a tree data structure. Each node can have 0-2 children(s).\nvisualization of a binary tree\n 2 / \\ / \\ / \\ 1 3 / \\ / \\ 0 7 9 1 / / \\ / \\ 2 1 0 8 8 Representation of a Node A node should contain the data(value) and reference to child nodes.","title":"Serializing \u0026 Deserializing Binary Tree"},{"content":"One of my non-techie friends was starting a new business and he wanted an Invoicing System. he reached out to me hoping that I can help him with a small website or app\nOpen Source Software to rescue If this was me a couple of years earlier I would have started the typical Software Development Life Cycle for a new project, but this new me is lazy. So, I searched the web to find a decent open-source project that can fulfil his needs for now, I came across this project it looked very interesting to me, it was using LaTeX to generate the invoice since I had no experience in the tools I refrained to use it (although I would love to explore it). after going through a couple of interesting looking projects, I found something familiar\nThe Base Serverless Invoices\n Create and manage invoices in your browser. \u0026ldquo;Serverless Invoices\u0026rdquo; is a free invoicing tool for freelancers and small businesses. Made with Vue.js.\n This was built using Vue.js and the result was a static website with some Javascript magic to handle the invoicing, it was also persistent data in browser storage. the codebase was clean and organized for anyone to build on top of that.\nIn the past I have built a website using Vue.js it was a good experience, after playing with the demo app I felt that it was only missing one major feature that can be added in a day and some layout related changes, so I decided to start with this as the base.\n  Invoice that the app already generates\n  Missing Feature The feature that I think was important and is missing was the ability to have custom columns in invoice and a couple of adjustments addition/removal of static sections, I created a form of the project and started tweaking the project to add the feature, I wanted to make the user specify the columns so that the layout of the invoice is also customizable.\nDeployment I made the so that by editing a config file a user can customize the columns, although I wanted to have some form of UI to do that. but since the self-defined deadlines were a little tight I decided to do that later.\n  After new UI components are added\n  The result was hosted hereinvoice.zkhan.in\n","permalink":"https://zkhan.in/posts/system/serverless-invoice/","summary":"One of my non-techie friends was starting a new business and he wanted an Invoicing System. he reached out to me hoping that I can help him with a small website or app\nOpen Source Software to rescue If this was me a couple of years earlier I would have started the typical Software Development Life Cycle for a new project, but this new me is lazy. So, I searched the web to find a decent open-source project that can fulfil his needs for now, I came across this project it looked very interesting to me, it was using LaTeX to generate the invoice since I had no experience in the tools I refrained to use it (although I would love to explore it).","title":"Serverless Invoice Generation"},{"content":"I use ubuntu as my daily driver so all the commands are going to be ubuntu/debian based\nInstallation Install conky-all package by sudo apt-get install conky-all\nSetup conky takes a config file to know what to draw on screen. the default location of config file is ~/.conkyrc\nRun you can start the conky by just typing conky in terminal, and a and ugly black window should come up.\nCustomization There are thousands of options to pick conky config, and if that\u0026rsquo;s not enough you can just google for more. I\u0026rsquo;ll add a link to my favorites one here, Conky Orange its 11 years old still looks decent\nyou can search for more on gnome-look or deviantart\nMy Conky Configurations I have 3 conky configs setup for my use, link to configs is here zkhan93/conky\n1. System monitor and time I use a modified version of conky Orange to use with my wallpaper\nconfigs and scripts used are zkhan93/conky/sidebar\n2. Quotes A conky script that shows a quote from a JSON file on disk.\nfor this I used startup apps in gnome to trigger a python script that downloads a Github gist which contains a bunch of my favorite quotes and pick one randomly. I had to use little bit of Lua since the quote can be arbitrarily long so Lua function takes care of multi line and alignment of text based on the font in use and its size.\n[ { \u0026#34;quote\u0026#34;: \u0026#34;Patience Ensures Victory.\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Ali ibn Abi Talib\u0026#34; } ] content of gist file have the following structure\nconfigs and scripts used are zkhan93/conky/quotes\n3. parcel tracking I want to stay updated on the location of my parcels, so invested some time to set this up so that the latest update on parcel is displayed on my screen. It is a combination of a couple of shell and lua scripts,\n bin/count.sh - counts the number of items to track bin/parcel_track.sh - Given the tracking number and courier service name it uses tracktry to get latest updates. bin/get_updates.sh - Uses count.sh to loop through each items and call parcel_track.sh for each item draw_status.lua - Uses count.sh and get_updates.sh to get the status and draw the status on screen .conkyrc - calls the draw_status.lua  Tracktry provides free API query credits per month for hobbyist\nRaspberry Pi 4,bluedart,8931267875 Aeroplane,bluedart,893114466875 text file contains tracking information\nconfigs and scripts used are zkhan93/conky/parcel\nImportant links  conky variables conky wiki  ","permalink":"https://zkhan.in/posts/system/conky-setup/","summary":"I use ubuntu as my daily driver so all the commands are going to be ubuntu/debian based\nInstallation Install conky-all package by sudo apt-get install conky-all\nSetup conky takes a config file to know what to draw on screen. the default location of config file is ~/.conkyrc\nRun you can start the conky by just typing conky in terminal, and a and ugly black window should come up.\nCustomization There are thousands of options to pick conky config, and if that\u0026rsquo;s not enough you can just google for more.","title":"Conky - Lightweight System Monitor"},{"content":"\u0026gt;\u0026gt;\u0026gt; uptime 09:20:04 up 13:22, 5 users, load average: 0.11, 0.31, 0.42 Load average are those three number, its these to give and idea of how busy the system is.\nIt shows load for last 1, 5 and 15 mins, A common misconception is that it just shows how busy the CPU is, however it also takes other IO operation into consideration.\nThis blog post explains it beautifully what those three numbers mean ","permalink":"https://zkhan.in/posts/understanding-linux-load-average/","summary":"\u0026gt;\u0026gt;\u0026gt; uptime 09:20:04 up 13:22, 5 users, load average: 0.11, 0.31, 0.42 Load average are those three number, its these to give and idea of how busy the system is.\nIt shows load for last 1, 5 and 15 mins, A common misconception is that it just shows how busy the CPU is, however it also takes other IO operation into consideration.\nThis blog post explains it beautifully what those three numbers mean ","title":"Understanding Linux load average"},{"content":"Hey Guys, wondering why I am here once again with this \u0026ldquo;factorial\u0026rdquo; thing? You will get to know it in no time..just keep reading!Let\u0026rsquo;s calculate some of the factorials:\n1! = 12! = 23! = 64! = 245! = 1206! = 720\nwell there is no problem, isn\u0026rsquo;t it?Continue then\u0026hellip;\n7! = 50408! = 40320\nNow let\u0026rsquo;s look at 21! It is 51090942171709440000\nHere comes the problem, in languages like C we need to keep an eye on the size of the variables. Even if we try storing the factorial in a long long int variable, it wont solve our problem.So what\u0026rsquo;s the solution? Think,think\u0026hellip;Well , it\u0026rsquo;s to use a character array. Let me show you how to do it, check out the code below:\n# include\u0026lt;stdio.h\u0026gt;  int factorial(int number){ int j = 0;\t/* Used as loop variable\t*/ int i = 0;\t/* Used for filling the array\t*/ int index = 0;\t/* To keep track of the index of the array\t*/ int temp = 0;\t/* Temporary variable used to hold diff values\t*/ int carry = 0;\t/*\tUsed to hold carry\t*/ char arr[200];\t/*\tUsed to store factorial\t*/ if (number \u0026lt;= 0)\treturn 1; for(i = 0 ; i \u0026lt; 200 ; i++) arr[i] = 0; i = 0; temp = number; /* Putting the number in the character array */ while (temp != 0){ arr[i++] = temp % 10; temp /= 10; } index = i; for ( j = number - 1 ; j \u0026gt; 1 ; j-- ) {\ti = 0;\tdo { temp = arr[i] * j + carry; arr[i] = temp % 10;\tcarry = temp / 10; i++; } while(carry \u0026gt; 0 || i \u0026lt; index); index = i;\t} /* Printing array in reverse order\t*/ printf(\u0026#34;Factorial of %d is : \u0026#34;,number); for (i =index - 1 ; i \u0026gt;= 0 ; i--) printf(\u0026#34;%d\u0026#34;,arr[i]); return 0; } int main(){ /*\tDeclaring variables\t*/ int num; /*\tAsking and scanning input\t*/ printf(\u0026#34;Enter a number : \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;num); /*\tPassing number to the function\t*/ factorial(num); return 0; } The output wil be as :\nEnter a number : 21 Factorial of 21 is : 51090942171709440000 Let me explain you the working of the factorial(int). As discussed earlier I have used character array arr[] for calculating the factorial, one digit at each index in reverse order.\nFirst of all if the number is less than or equal to 0 we will simply return as there is no point in calculating its factorial.Next I have stored a \u0026lsquo;0\u0026rsquo; at all the indices of arr in order to avoid any absurd value using the for loop.(You will get to know the reason later on) After that there is a while loop which I have used to store the number in the arr in the reverse order.Suppose the user wants the factorial of 21,then we will have the following values in our array:arr[0] = 1, arr[1] = 2 Also we need to keep track of the index till where we have a valid value.Now we are going to calculate the factorial, i.e. 21 * 20 * 19 \u0026hellip;.* 2 * 1\nThe for loop What I am gonna do is to loop through the number-1 (20) till 2. In this loop, I will multiply the number that is stored in the array to the loop variable (j) and store the result back in the character array(again digit wise and in reverse order). For instance, in the first iteration of for loop, what I have done is that I have multiplied 21(arr) by 20(j) and stored the result back in arr[] , the values will be as:arr[0] = 0, arr[1] = 2, arr[2] = 4, (remember reverse order?)\nNow lets understand how this 12 became 024 (reverse of 420 (21*20))\nThe do-while loop. Look at the following line:temp = arr[i] * j + carry;\t(1 * 20 + 0)\tHere, temp is used to temporarily hold the value of the product of the last digit(1) and the iteration variable j(20). The result comes out to be 20.Next , arr[i] = temp % 10 stores the last digit of temp variable in the first index of arr, i.e., 0 will be stored at arr[0]. carry = temp / 10 stores the remaining digits(2) of the value of temp variable,i.e., 2 will be stored in carry. After this, we\u0026rsquo;ll do an i++ (i becomes 1) in order to keep record of number of digits that have been multiplied in this iteration.while(carry \u0026gt; 0 || i \u0026lt; index)line checks if we have multiplied j with all the digits of the arr or not. Notice the carry \u0026gt; 0 statement, it is to check whether there is any carry left or not. And since we have a carry \u0026lsquo;2\u0026rsquo; we\u0026rsquo;ll again enter the while loop and this time,\ttemp = arr[i] * j + carry; (2 * 20 + 2) stores 42 in temp. Hence, arr[i] = temp % 10 will store 2 at a[1] and carry = temp / 10 will store 4 in carry which, in the next iteration of while, will be stored at a[2](try a dry run in your mind to picture how this wil happen). Therefore, coming out of the do-while loop at this time, the values of arr will be as follows:arr[0] = 0, arr[1] = 2, arr[2] = 4 and carry = 0 and at this point we\u0026rsquo;ll update the value of index also.\nLikewise each value of jis multiplied in the value stored in arr.\nLastly, after coming out of the for loop we have to print the number stored in the arr, but remember in the reverse order, starting from index-1 to 0.\nAnd that\u0026rsquo;s it, now you can calculate factorial of any number, and if you want you can even increase the size of arr and now, even more bigger numbers. Easy it was..isn\u0026rsquo;t it?\n","permalink":"https://zkhan.in/posts/c/factorial-in-c-using-array/","summary":"Hey Guys, wondering why I am here once again with this \u0026ldquo;factorial\u0026rdquo; thing? You will get to know it in no time..just keep reading!Let\u0026rsquo;s calculate some of the factorials:\n1! = 12! = 23! = 64! = 245! = 1206! = 720\nwell there is no problem, isn\u0026rsquo;t it?Continue then\u0026hellip;\n7! = 50408! = 40320\nNow let\u0026rsquo;s look at 21! It is 51090942171709440000\nHere comes the problem, in languages like C we need to keep an eye on the size of the variables.","title":"Factorial in C using Character array"},{"content":"Hey! Today i am gonna show you how to calculate factorial of a number. The code below depicts the basic methodology of how to calculate factorial of a number.\n# include\u0026lt;stdio.h\u0026gt;  void factorial(int number){ int i; long long int factorial=1; for ( i = number ; i \u0026gt; 0 ; i-- ) factorial*=i; //\tPrinting the factorial of the number\t**/ \tprintf(\u0026#34;Factorial of %d = %lld\u0026#34;,number,factorial); return 0; } int main(){ //\tDeclaring variables\t**/  int num; //\tAsking and scanning input\t**/  printf(\u0026#34;Enter a number : \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;num); //\tPassing number to the function\t**/  factorial(num); return 0; } output of above code will be\nEnter a number : 5 Factorial of 5 = 120 So, as you have seen the code simply takes up a integer and passes it to the factorial() function which in turns prints up the factorial of that number.\nfactorial() is simply based on the technique of how we calculate factorial on pen and paper as :\n5! = 5 * 4* 3* 2* 1 = 120\nWell, this was just a simple program on factorial, I will come up soon with some awesome programs! Keep coding till then!\n","permalink":"https://zkhan.in/posts/c/factorial-in-c/","summary":"Hey! Today i am gonna show you how to calculate factorial of a number. The code below depicts the basic methodology of how to calculate factorial of a number.\n# include\u0026lt;stdio.h\u0026gt;  void factorial(int number){ int i; long long int factorial=1; for ( i = number ; i \u0026gt; 0 ; i-- ) factorial*=i; //\tPrinting the factorial of the number\t**/ \tprintf(\u0026#34;Factorial of %d = %lld\u0026#34;,number,factorial); return 0; } int main(){ //\tDeclaring variables\t**/  int num; //\tAsking and scanning input\t**/  printf(\u0026#34;Enter a number : \u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;num); //\tPassing number to the function\t**/  factorial(num); return 0; } output of above code will be","title":"Factorial in C"},{"content":"First let\u0026rsquo;s get familiar with some basic terminologies used in linked list.\n A linked list is a type of array in which each elements points to the next element. Each element in the list is called a node The very first node of the list is called the root node or head of the list. Linked list is represented only by the root node i.e., we store only the pointer to the root node. Memory for each node is dynamically allocated using malloc() or calloc() function from stdlib.h header file. Allocated memory should be released after use, using free() function.  Now let\u0026rsquo;s look at the code below, although the code is self explanatory we will explain each portion separately.\n#include\u0026lt;stdio.h\u0026gt;#include\u0026lt;stdlib.h\u0026gt;/** * Structure of one node of the Linked List **/ typedef struct node{ int value; struct node* next; }node; /** * This fucntion prints the whole linked list on console in the below format, * value1-\u0026gt;value2-\u0026gt;value3...-\u0026gt;valuen * eg. 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 * if the list is empty it simply prints a message \u0026#39;List is Empty\u0026#39; * @parmeters * node* head: head or root of the linked list, * i.e., pointer pointing to the first item(more formally first node) in the linked list. * **/ void printList(node* head){ if(head!=\u0026#39;\\0\u0026#39;){ node* tmpNode=head; while(tmpNode!=\u0026#39;\\0\u0026#39;){ printf(\u0026#34;%d\u0026#34;,tmpNode-\u0026gt;value); tmpNode=tmpNode-\u0026gt;next; if(tmpNode!=\u0026#39;\\0\u0026#39;) printf(\u0026#34;-\u0026gt;\u0026#34;); else printf(\u0026#34;\\n\u0026#34;); } } else printf(\u0026#34;List is Empty\\n\u0026#34;); } /** * This function add a node to the end of the linked list, i.e., the newNode will be the last node in the existing linked list, * if the list is empty the newNode become the first node of the list * @parmeters * node* head: pointer pointing to the start of the list (head or root node) * node* newNode: pointer pointing to the new node. **/ node* addNodeToEnd(node* head, node* newNode){ if(head==\u0026#39;\\0\u0026#39;){ //newNode is the first node to the list  head=newNode; } else{ node* tmpNode=head; while(tmpNode-\u0026gt;next!=\u0026#39;\\0\u0026#39;){ tmpNode=tmpNode-\u0026gt;next; } tmpNode-\u0026gt;next=newNode; } return head; } /** * This function add a node to the start of the linked list * @parameters **/ node* addNodeToStart(node* head,node* newNode){ if(head==\u0026#39;\\0\u0026#39;){ head=newNode; } else{ node* tmpNode=head; head=newNode; newNode-\u0026gt;next=tmpNode; } return head; } /** * This function add a new node, after a specified value in the list * @parameters * node* head: pointer of type node, pointing to the start of the list * node* newNode: pointer of type node, pointing to the newly created node(i.e., the new node to be inserted) * int value: value after which newNode has to be inserted **/ node* addNodeAfterValue(node* head,node* newNode,int value){ int found=0; if(head!=\u0026#39;\\0\u0026#39;){ node* tmpNode=head; while(tmpNode-\u0026gt;next!=\u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; tmpNode-\u0026gt;value!=value){ tmpNode=tmpNode-\u0026gt;next; } if(tmpNode-\u0026gt;value==value){ newNode-\u0026gt;next=tmpNode-\u0026gt;next; tmpNode-\u0026gt;next=newNode; found=1; } } if(!found) printf(\u0026#34;cannot find %d in the list\\n\u0026#34;,value); return head; } /** * This function add a new node, before a specified value in the list. * @parameters * node* head: pointer of type node, pointing to the start of the list * node* newNode: pointer of type node, pointing to the newly created node(i.e., the new node to be inserted) * int value: value before which newNode has to be inserted. **/ node* addNodeBeforeValue(node* head,node* newNode,int value){ int found=0; if(head!=\u0026#39;\\0\u0026#39;){ if(head-\u0026gt;value==value){ head=addNodeToStart(head,newNode); found=1; } else{ node* tmpNode=head; while(tmpNode-\u0026gt;next!=\u0026#39;\\0\u0026#39; \u0026amp;\u0026amp; tmpNode-\u0026gt;next-\u0026gt;value!=value){ tmpNode=tmpNode-\u0026gt;next; } if(tmpNode-\u0026gt;next-\u0026gt;value==value){ newNode-\u0026gt;next=tmpNode-\u0026gt;next; tmpNode-\u0026gt;next=newNode; found=1; } } } if(!found) printf(\u0026#34;cannot find %d in the list\\n\u0026#34;,value); return head; } /** * This function free up all the memory attached with specified node * @parmeters * node* head: root of the list **/ void freeNode(node* head){ if(head-\u0026gt;next==\u0026#39;\\0\u0026#39;) free(head); else freeNode(head-\u0026gt;next); } /** * This function create a new node from memory pool, * assign a value to the value variable in the node and return it\u0026#39;s pointer; * @parmeters * int value: the value to be assigned to the new node. **/ node* getNewNodeWithValue(int value){ //getting memory from free pool.  node* newNode=(node*)malloc(sizeof(node)); //assigning value to the node\u0026#39;s value member  newNode-\u0026gt;value=value; //setting next pointer to null  newNode-\u0026gt;next=\u0026#39;\\0\u0026#39;; return newNode; } int main(){ //initially head points to null ie., list is empty  node* head=\u0026#39;\\0\u0026#39;; node* tmpNode; int i=0; //Adding 5 new nodes to the end of the list  // result should be 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5  for(i=1;i\u0026lt;=5;i++){ tmpNode=getNewNodeWithValue(i); //adding this new node to the end of the list  head=addNodeToEnd(head,tmpNode); //printing the list  printList(head); } //Adding next 5 values to the start of the list  // result should be 10-\u0026gt;9-\u0026gt;8-\u0026gt;7-\u0026gt;6-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5  for(i=6;i\u0026lt;=10;i++){ tmpNode=getNewNodeWithValue(i); //adding this new node to the start of the list  head=addNodeToStart(head,tmpNode); //printing the list  printList(head); } //Adding 11 after 6  //result should be 10-\u0026gt;9-\u0026gt;8-\u0026gt;7-\u0026gt;6-\u0026gt;11-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5  tmpNode=getNewNodeWithValue(11); head=addNodeAfterValue(head,tmpNode,6); printList(head); //Adding 12 before 2  //result should be 10-\u0026gt;9-\u0026gt;8-\u0026gt;7-\u0026gt;6-\u0026gt;11-\u0026gt;1-\u0026gt;12-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5  tmpNode=getNewNodeWithValue(12); head=addNodeBeforeValue(head,tmpNode,2); printList(head); //free up all the allocated memory  freeNode(head); return 0; } So, we have 7 functions excluding main() let\u0026rsquo;s have a breif introduction,\n printList(node*) print the current list on console. addNodeToEnd(node*,node*) add a node to end of list. addNodeToStart(node*,node*) add a new node to the beginning of list. addNodeAfterValue(node*,node*,int) add a new node after a specific value. addNodeBeforeValue(node*,node*,int) add a new node before a specific value. freeNode(node*) free up the memory associated with this node and other linked nodes. getNewNodeWithValue(int) get a new node with a specific value.  Function main() Let\u0026rsquo;s start with the main(), we define two node type pointers head and tmpNode, head will point to the root node, let\u0026rsquo;s leave tmpNode for now it will be used later. Initially the root node is null , now we are adding 5 new nodes (values 1 to 5) at the end of the list using addNodeToEnd(), we are printing the entire list after each operation, so that we can track the changes in the list, after that we are adding 5 more new nodes (values 6 to 10) at the start of the list using addNodeToStart() , again we are printing the entire list after each operation, at this point we will be having a linked list similar to 10-\u0026gt;9-\u0026gt;8-\u0026gt;7-\u0026gt;6-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, now we try to add 3 new nodes using addNodeAfterValue(), nodes will be having values 11, 12 and 13, they will be added after 10, 5 and 8 respectively. at this point our link list will look like 10-\u0026gt;11-\u0026gt;9-\u0026gt;8-\u0026gt;13-\u0026gt;7-\u0026gt;6-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;12, after this we will test addNodeBeforeValue() by adding 3 new nodes, nodes will be having values 14, 15 and 16, they will be added before 10, 12 and 13 respectively.\nFunction addNodeToEnd() addNodeToEnd() take two arguments, first argument is a pointer to root node and second is pointer to new node, let\u0026rsquo;s look at the definition of addNodeToEnd() (44-57) to understand the working, first we check head for null if so we simply make the new node as the root node by head=newNode, else we take a temporary pointer variable tmpNode initially pointing to root node, we move forward by tmpNode=tmpnode-\u0026gt;next till we reach the end of the list ie., tmpNode-\u0026gt;next=='\\0', at this point tmpNode will be pointing to the last node, now the last node should point to the new node we do this by tmpNode-\u0026gt;next=newNode, finally we return the root node.\nFunction addNodeToStart() addNodeToStart() takes two arguments, first argument is a pointer to root node and second is pointer to new node, looking at the definition of addNodeToEnd() (63-73) we see that we first check head for null, if so then we simple make the the new node as the root node by head=newNode, otherwise newNode should point to root node i.e., newNode-\u0026gt;next=head now newNode can be treated as the root node so head=newNode, finally returning the root node, we can also skip the null check part so that our function look like\nnode* addNodeToStart(node* head, node* newNode){ newNode-\u0026gt;next=head; head=newNode; return head; } either version of the function will do the job.\nFunction addNodeAfterValue() addNodeAfterValue() takes three arguments, first argument is a pointer to the root node, second is a pointer to new node and third argument is a value after which new node will be inserted, looking at the definition (81-97), here again we check head for null, if so we have nothing to do as the list is empty, else we take a temporary variable tmpNode, now we move forward till we reach at the end of the list i.e., tmpNode-\u0026gt;next=='\\0' or find the desired value i.e., tmpNode-\u0026gt;value==value (equivalent while loop condition will be while(tmpNode-\u0026gt;next!='\\0' \u0026amp;\u0026amp; tmpNode-\u0026gt;value!=value)), after the loop we will check if the current node has the desired value or not because we have two conditions on which the loop terminates, if the value matches with the desired value then will make the newNode to point to whatever is pointed by the current node i.e., newNode-\u0026gt;next=tmpNode-\u0026gt;next, and then make the current node to point to the new node i.e., tmpNode-\u0026gt;next=newNode. We use found variable to track that we found the value in list or not depending on which we print a suitable message and finally return the root node;\nFunction addNodeBeforeValue() addNodeBeforeValue() takes three arguments, first argument is a pointer to the root node, second is the pointer to new node and third argument is a value before which a new node will be inserted, looking at the definition (107-129), we first check head for null, if so we have nothing to do as the list is empty, otherwise we check head\u0026rsquo;s value by head-\u0026gt;value==value if so then newNode must be added before the root/head node, we use our addNodeToStart() method for this i.e., head=addNodeToStart(head,nodeNode), on the other hand if the value of root node does not match with the desired value then we take a temporary variable tmpNode=head initially pointing to root node and move forward till we reach the end tmpNode-\u0026gt;next=='\\0' or find the desired value in the node next to the current one tmpnode-\u0026gt;next-\u0026gt;value==value we do this to stay behind the node with desired value (equivalent while loop condition will be while(tmpNode-\u0026gt;next!='\\0' \u0026amp;\u0026amp; tmpnode-\u0026gt;next-\u0026gt;value!=value)), after the loop ends we may be on the last node or before the desired node, so we check the value of next node with value i.e., tmpNode-\u0026gt;next-\u0026gt;value==value if this condition is true then we insert the new node before the current node, this is accomplished by first making newNode to point whatever tmpNode is pointing at newNode-\u0026gt;next=tmpNode-\u0026gt;next then make the current node point to new node i.e., tmpNode-\u0026gt;next=newNode, we also use found variable to track whether the desired value exist in the list or not and printing a suitable message respectively and finally return the root node.\n","permalink":"https://zkhan.in/posts/c/linked-list-in-c/","summary":"First let\u0026rsquo;s get familiar with some basic terminologies used in linked list.\n A linked list is a type of array in which each elements points to the next element. Each element in the list is called a node The very first node of the list is called the root node or head of the list. Linked list is represented only by the root node i.e., we store only the pointer to the root node.","title":"Linked List in C"},{"content":"The best way to scan input in java includes the use of BufferedReader class, another method uses Scanner class but is slower, so here we will prefer BufferedReader.\nThe following code demonstrate the use of BufferedReader for scanning input of different type.\n// file ScanInput.java import java.io.*; public class ScanInput{ public static void main(String args[]) throws IOException{ BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); System.out.print(\u0026#34;Enter a String: \u0026#34;); String msg=br.readLine(); System.out.print(\u0026#34;Enter a Integer: \u0026#34;); int integer=Integer.parseInt(br.readLine()); System.out.print(\u0026#34;Enter a Decimal Number: \u0026#34;); Float float_number=Float.parseFloat(br.readLine()); System.out.println(\u0026#34;String you entered is:\u0026#34;+msg); System.out.println(\u0026#34;Integer you entered is:\u0026#34;+integer); System.out.println(\u0026#34;Decimal Number you entered is:\u0026#34;+float_number); } } output is\nEnter a String: Hello World!! Enter a Integer: 12345 Enter a Decimal Number: 123.345221 String you entered is:Hello World!! Integer you entered is:12345 Decimal Number you entered is:123.34522 ","permalink":"https://zkhan.in/posts/java/how-to-scan-input-in-java/","summary":"The best way to scan input in java includes the use of BufferedReader class, another method uses Scanner class but is slower, so here we will prefer BufferedReader.\nThe following code demonstrate the use of BufferedReader for scanning input of different type.\n// file ScanInput.java import java.io.*; public class ScanInput{ public static void main(String args[]) throws IOException{ BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); System.out.print(\u0026#34;Enter a String: \u0026#34;); String msg=br.readLine(); System.out.print(\u0026#34;Enter a Integer: \u0026#34;); int integer=Integer.","title":"How To Scan Input In Java"},{"content":"Sometimes we need to scan input really fast like when we are participating in coding competitions like codechef or SPOJ where the time limit is very strict and inputs are large, we can save some time by adopting faster scanning methods.\nWe can achieve our gaol using getchar_unlocked function.\ncode below scans 100000 integers and has two different methods one is scan_normal() this will scan integers using standard scanf() function and the other one is scan_fast() this scan integers using getchar_unlocked function, we will execute the program twice one for each method mark the time taken for execution to evaluate the performance.\n#include\u0026lt;stdio.h\u0026gt;#define gc getchar_unlocked // gc for saving for getchar_unlocked int scan_fast(){ int n=0; char ch=gc(); while(ch \u0026lt; \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026gt;\u0026#39;9\u0026#39;){ ch=gc(); // ignoring chars that are not digit \t} while(ch\u0026gt;=\u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch\u0026lt;=\u0026#39;9\u0026#39;){ n=n*10+ch-\u0026#39;0\u0026#39;; // for each digit add it to n in proper place \tch=gc(); } return n; } int scan_normal(){ int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); return n; } int main(){ int num=1000000; //we have 100000 integers to test \twhile(num--){ //\tscan_normal(); // uncomment this for 1st execution \t//\tscan_fast(); // uncomment this for 2nd execution \t} return 0; } for checking i am using linux time command to check the execution time and a file text-file.txt containing 100000 integers from 0 to 99999\ncommand is as follows\ntime ./scan_methods \u0026lt; text-file.txt output using scan_normal\nreal\t0m0.112s user\t0m0.101s sys\t0m0.012s output using scan_fast\nreal\t0m0.040s user\t0m0.033s sys\t0m0.008s ","permalink":"https://zkhan.in/posts/c/fast-input-scan-method-in-c/","summary":"Sometimes we need to scan input really fast like when we are participating in coding competitions like codechef or SPOJ where the time limit is very strict and inputs are large, we can save some time by adopting faster scanning methods.\nWe can achieve our gaol using getchar_unlocked function.\ncode below scans 100000 integers and has two different methods one is scan_normal() this will scan integers using standard scanf() function and the other one is scan_fast() this scan integers using getchar_unlocked function, we will execute the program twice one for each method mark the time taken for execution to evaluate the performance.","title":"Faster Input Scan Method in C"},{"content":"To run a java program you must have one, so lets have a sample code which prints \u0026ldquo;Hello world!!\u0026rdquo; to console.\nSource Code If you have source code ready then ignore else create a new file Hello.java and copy the below code in it and save it.\nSource code\n// file Hello.java import java.io.*; class Hello{ public static void main(String args[]){ System.out.println(\u0026#34;Hello World!!\u0026#34;); } } now you have your source code ready,\n###Compile\nOpen a terminal or command prompt navigate to the directory where you source code resides using command cd, now to compile the source code type javac \u0026lt;Source File Name\u0026gt; so in our case we will write javac Hello.java this will create .class files in the directory.\nIf there is error in source code you will see error messages, resolve error and repeat the compilation process unless there is no message from compiler.\nExecute To execute the program type java \u0026lt;Class Name\u0026gt; so in this case we have java Hello.\nHello world!! ","permalink":"https://zkhan.in/posts/java/how-to-run-java-program/","summary":"To run a java program you must have one, so lets have a sample code which prints \u0026ldquo;Hello world!!\u0026rdquo; to console.\nSource Code If you have source code ready then ignore else create a new file Hello.java and copy the below code in it and save it.\nSource code\n// file Hello.java import java.io.*; class Hello{ public static void main(String args[]){ System.out.println(\u0026#34;Hello World!!\u0026#34;); } } now you have your source code ready,","title":"How To Run a Java Program"},{"content":"The following program demonstrate how we can implement simple client server architecture in java Start Server.java in a terminal/command prompt then open another command prompt/terminal and start Client.java in it Server can handle new Clients on disconnection of previous one.\nCode for Server\n// file Server.java import java.io.*; import java.net.*; class Server{ static ServerSocket ss; Socket cs; static int PORT=12345; static String EXIT_STRING=\u0026#34;terminate\u0026#34;; static String SERVER_PREFIX=\u0026#34;Eco msg: \u0026#34;; BufferedReader reader; PrintWriter writer; static boolean connected; public static void main(String args[]){ Server mServer=new Server(); try{ ss=new ServerSocket(PORT); while(true){ mServer.getClient(); mServer.echoToClient(); } }catch(Exception e){ e.printStackTrace(); } } public void getClient() throws Exception{ System.out.println(\u0026#34;Server waiting for Client..\u0026#34;); cs=ss.accept(); reader=new BufferedReader(new InputStreamReader(cs.getInputStream())); writer=new PrintWriter(cs.getOutputStream(),true); System.out.println(\u0026#34;Client Connected and configured.\u0026#34;); } public void echoToClient() throws Exception{ String msg; while(!((msg=reader.readLine()).equalsIgnoreCase(EXIT_STRING))){ writer.println(msg); System.out.println(SERVER_PREFIX+msg); } writer.println(msg); System.out.println(\u0026#34;Client quits..\u0026#34;); } } Code for client\n// file Client.java import java.io.*; import java.net.*; class Client{ Socket s; static int PORT=12345; static String EXIT_STRING=\u0026#34;terminate\u0026#34;; static String CLIENT_PREFIX=\u0026#34;Server said: \u0026#34;; static BufferedReader user_reader; static BufferedReader server_reader; static PrintWriter writer; static boolean terminate; public static void main(String args[]) throws IOException{ Client mClient=new Client(); user_reader=new BufferedReader(new InputStreamReader(System.in)); if(mClient.connect()){ System.out.println(\u0026#34;Connected to Server\u0026#34;); //new Thread(new ListenToUser()).start(); \tnew Thread(new ListenToServer()).start(); mClient.ListenToUser(); } } public boolean connect(){ try{ s=new Socket(\u0026#34;127.0.0.1\u0026#34;,PORT); server_reader=new BufferedReader(new InputStreamReader(s.getInputStream())); writer=new PrintWriter(s.getOutputStream(),true); return true; }catch(Exception e){ e.printStackTrace(); return false; } } public void ListenToUser(){\tString msg; try{ do{ msg=user_reader.readLine(); writer.println(msg); }while(!msg.equalsIgnoreCase(EXIT_STRING)); terminate=true; }catch(Exception e){ e.printStackTrace(); } } static class ListenToServer implements Runnable{ @Override public void run(){ String msg; try{ while(!terminate){ msg=server_reader.readLine(); if(msg.equalsIgnoreCase(EXIT_STRING)) break; else System.out.println(CLIENT_PREFIX+msg); } }catch(Exception e){ e.printStackTrace(); } System.out.println(\u0026#34;Disconnected from server\u0026#34;); } } } Client output\nConnected to Server Hi Server Server said: Hi Server you just eco what I say Server said: you just eco what I say okay bye Server said: okay bye terminate Disconnected from server Server output\nServer waiting for Client.. Client Connected and configured. Eco msg: Hi Server Eco msg: you just eco what I say Eco msg: okay bye Client quits.. Server waiting for Client.. ","permalink":"https://zkhan.in/posts/java/client-server-in-java/","summary":"\u003cp\u003eThe following program demonstrate how we can implement simple client server architecture in java\nStart \u003ccode\u003eServer.java\u003c/code\u003e in a terminal/command prompt then open another command prompt/terminal and start \u003ccode\u003eClient.java\u003c/code\u003e in it\nServer can handle new Clients on disconnection of previous one.\u003c/p\u003e","title":"Client Server in Java"},{"content":"ArrayList is a collection of data items that grows and shrinks depending on the number of data items present in it, you can think it as a dynamic array or a link lists in C, whose size increases when we insert a data and decreases as delete some data from it.\nTo insert a data item we use add() method and to delete we use remove() method as demonstrated below in line 13 and 20 respectively.\nfollowing code shows how we can use ArrayList in java\n// file ArrayListDemo.java import java.io.*; import java.util.*; public class ArrayListDemo{ public static void main(String args[]) throws IOException{ ArrayList\u0026lt;String\u0026gt; array_of_string=new ArrayList\u0026lt;String\u0026gt;(); String str; int index; BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); System.out.println(\u0026#34;Enter data to insert in arraylist\u0026#34;); //type \u0026#34;end\u0026#34; to stop \twhile((str=br.readLine()).equalsIgnoreCase(\u0026#34;end\u0026#34;)==false){ //loop ends when user types \u0026#34;end\u0026#34; \tarray_of_string.add(str); //adding data to arraylist \tSystem.out.println(\u0026#34;Inserted a data size of arrayList is \u0026#34;+array_of_string.size()); } System.out.println(\u0026#34;\\n------------\\nEnter the index to delete data item\u0026#34;); while(array_of_string.size()\u0026gt;0){ index=Integer.parseInt(br.readLine()); if(index\u0026gt;-1 \u0026amp;\u0026amp; index\u0026lt;array_of_string.size()){ array_of_string.remove(index); //deleting data from arraylist \tSystem.out.println(\u0026#34;Item at \u0026#34;+index+\u0026#34; deleted now array contains \u0026#34;+array_of_string.size()+\u0026#34; elements\u0026#34;); } else System.out.println(\u0026#34;Enter a valid index\u0026#34;); } System.out.println(\u0026#34;Array is now empty\u0026#34;); } } the output of above code will be\nEnter data to insert in arraylist hello Inserted a data size of arrayList is 1 hi Inserted a data size of arrayList is 2 anyone Inserted a data size of arrayList is 3 there? Inserted a data size of arrayList is 4 no one ? Inserted a data size of arrayList is 5 :( Inserted a data size of arrayList is 6 end ------------ Enter the index to delete data item 6 Enter a valid index 5 Item at 5 deleted now array contains 5 elements 4 Item at 4 deleted now array contains 4 elements 3 Item at 3 deleted now array contains 3 elements 3 Enter a valid index 2 Item at 2 deleted now array contains 2 elements 1 Item at 1 deleted now array contains 1 elements 0 Item at 0 deleted now array contains 0 elements Array is now empty ","permalink":"https://zkhan.in/posts/java/arraylist-in-java/","summary":"ArrayList is a collection of data items that grows and shrinks depending on the number of data items present in it, you can think it as a dynamic array or a link lists in C, whose size increases when we insert a data and decreases as delete some data from it.\nTo insert a data item we use add() method and to delete we use remove() method as demonstrated below in line 13 and 20 respectively.","title":"ArrayList in java"},{"content":"The following program demonstrate how we to perform read and write operations on files,\nWe can create and open a file w+ (write plus) mode, this will open a file if it exists otherwise create a new file and open it in write mode\n# include\u0026lt;stdio.h\u0026gt; int main(void){ FILE *fp; char str[100]; // w+ create or open if exist in write mode \tfp = fopen(\u0026#34;myfile.txt\u0026#34;, \u0026#34;w+\u0026#34;); fputs(\u0026#34;hello world!!..this is a text\u0026#34;,fp); fclose(fp); fp = fopen(\u0026#34;myfile.txt\u0026#34;, \u0026#34;r\u0026#34;); fgets(str, 100, fp); printf(\u0026#34;file contain:\\n%s\\n\u0026#34;, str); fclose(fp); return 0; } Output:\nfile contain: hello world!!..this is a text ","permalink":"https://zkhan.in/posts/c/file-hadling-in-c/","summary":"\u003cp\u003eThe following program demonstrate how we to perform read and write operations on files,\u003c/p\u003e\n\u003cp\u003eWe can create and open a file \u003ccode\u003ew+\u003c/code\u003e (write plus) mode, this will open a file if it exists otherwise create a new file and open it in write mode\u003c/p\u003e","title":"File Handling in C"},{"content":"Dynamic array is a array that has a fixed number of items on it, but the space required for data storage is alloted at runtime on data input.\nThe code below will demonstrate how we can use dynamic array in C\n# include\u0026lt;stdio.h\u0026gt; # include\u0026lt;stdlib.h\u0026gt;  int main() { int *arr[10], i; printf(\u0026#34;Enter 10 numbers\\n\u0026#34;); for(i = 0; i \u0026lt; 10; i++){ //asking for space to store an int \tarr[i] = (int*) malloc(sizeof(int)); scanf(\u0026#34;%d\u0026#34;, arr[i]); } printf(\u0026#34;the array you entered is \u0026#34;); for(i = 0; i \u0026lt; 10; i++){ printf(\u0026#34;%d \u0026#34;, *arr[i]); //returning memory to system \tfree(arr[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } The above code will produce the following output\nEnter 10 numbers 1 2 3 4 5 6 7 8 9 10 the array you entered is 1 2 3 4 5 6 7 8 9 10 ","permalink":"https://zkhan.in/posts/c/dynamic-array-in-c/","summary":"Dynamic array is a array that has a fixed number of items on it, but the space required for data storage is alloted at runtime on data input.\nThe code below will demonstrate how we can use dynamic array in C\n# include\u0026lt;stdio.h\u0026gt; # include\u0026lt;stdlib.h\u0026gt;  int main() { int *arr[10], i; printf(\u0026#34;Enter 10 numbers\\n\u0026#34;); for(i = 0; i \u0026lt; 10; i++){ //asking for space to store an int \tarr[i] = (int*) malloc(sizeof(int)); scanf(\u0026#34;%d\u0026#34;, arr[i]); } printf(\u0026#34;the array you entered is \u0026#34;); for(i = 0; i \u0026lt; 10; i++){ printf(\u0026#34;%d \u0026#34;, *arr[i]); //returning memory to system \tfree(arr[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } The above code will produce the following output","title":"Dynamic array in C"},{"content":"Pointers are variables that stores the reference (address) of a data value, datatype of pointers represent what kind of values they can hold reference of, however, a pointer of type void can hold reference of any datatype, but explicitly type casting is required to use them.\nThe code below will demonstrate how we can use pointers in C\n# include\u0026lt;stdio.h\u0026gt; int main(){ int *pnum, num; printf(\u0026#34;Enter a number\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); pnum = \u0026amp;num; // now you can modify the value from pnum as well as num. \t*pnum += 10; printf(\u0026#34;new value of num=%d\\n\u0026#34;, num); return 0; } Output:\nEnter a number 27 new value of num=37 ","permalink":"https://zkhan.in/posts/c/pointers-in-c/","summary":"Pointers are variables that stores the reference (address) of a data value, datatype of pointers represent what kind of values they can hold reference of, however, a pointer of type void can hold reference of any datatype, but explicitly type casting is required to use them.\nThe code below will demonstrate how we can use pointers in C\n# include\u0026lt;stdio.h\u0026gt; int main(){ int *pnum, num; printf(\u0026#34;Enter a number\\n\u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;num); pnum = \u0026amp;num; // now you can modify the value from pnum as well as num.","title":"Pointers in C"},{"content":"Arrays in C are collection of values that have same data types.\nThe code below initializes and assigns values to an each position in an array\n# include\u0026lt;stdio.h\u0026gt;  int main(){ int arr[10]; int i; printf(\u0026#34;Enter 10 numbers\\n\u0026#34;); for(i=0;i\u0026lt;10;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;arr[i]); } printf(\u0026#34;the array you entered is\\n\u0026#34;); for(i=0;i\u0026lt;10;i++){ printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Output:\nEnter 10 numbers 1 2 3 4 5 6 7 8 9 10 the array you entered is 1 2 3 4 5 6 7 8 9 10 \u0026#39;\u0026#39;\u0026#39; ","permalink":"https://zkhan.in/posts/c/array-in-c/","summary":"Arrays in C are collection of values that have same data types.\nThe code below initializes and assigns values to an each position in an array\n# include\u0026lt;stdio.h\u0026gt;  int main(){ int arr[10]; int i; printf(\u0026#34;Enter 10 numbers\\n\u0026#34;); for(i=0;i\u0026lt;10;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;arr[i]); } printf(\u0026#34;the array you entered is\\n\u0026#34;); for(i=0;i\u0026lt;10;i++){ printf(\u0026#34;%d \u0026#34;,arr[i]); } printf(\u0026#34;\\n\u0026#34;); return 0; } Output:\nEnter 10 numbers 1 2 3 4 5 6 7 8 9 10 the array you entered is 1 2 3 4 5 6 7 8 9 10 \u0026#39;\u0026#39;\u0026#39; ","title":"Array in C"},{"content":"Bitwise operators in C are\n \u0026amp; AND Operator | OR Operator ~ NOT Operator ^ XOR Operator  The code below demonstrate common bitwise operations in c\n# include\u0026lt;stdio.h\u0026gt; int main(){ int a, b, option, res; printf(\u0026#34;Enter a and b\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); do{ printf(\u0026#34;MENU\\n1.AND\\n2.OR\\n3.NOT \\n4.XOR\\n0.Exit\\n\u0026#34;); printf(\u0026#34;Enter choice: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;option); switch(option){ case 1: res = a \u0026amp; b; printf(\u0026#34;%d AND %d = %d\\n\u0026#34;, a, b, res); break; case 2: res = a | b; printf(\u0026#34;%d OR %d = %d\\n\u0026#34;, a, b, res); break; case 3: res = ~a; printf(\u0026#34;NOT of %d = %d\\n\u0026#34;, a, res); res = ~b; printf(\u0026#34;NOT of %d = %d\\n\u0026#34;, b, res); break; case 4: res = a ^ b; printf(\u0026#34;%d XOR %d = %d\\n\u0026#34;, a, b, res); break; default: break; } printf(\u0026#34;\\n\u0026#34;); }while(option); return 0; } Output:\nEnter a and b 2 3 MENU 1.AND 2.OR 3.NOT 4.XOR 0.Exit Enter choice: 1 2 AND 3 = 2 MENU 1.AND 2.OR 3.NOT 4.XOR 0.Exit Enter choice: 2 2 OR 3 = 3 MENU 1.AND 2.OR 3.NOT 4.XOR 0.Exit Enter choice: 3 NOT of 2 = -3 NOT of 3 = -4 MENU 1.AND 2.OR 3.NOT 4.XOR 0.Exit Enter choice: 4 2 XOR 3 = 1 MENU 1.AND 2.OR 3.NOT 4.XOR 0.Exit Enter choice: 0 ","permalink":"https://zkhan.in/posts/c/bitwise-operator-in-c/","summary":"Bitwise operators in C are\n \u0026amp; AND Operator | OR Operator ~ NOT Operator ^ XOR Operator  The code below demonstrate common bitwise operations in c\n# include\u0026lt;stdio.h\u0026gt; int main(){ int a, b, option, res; printf(\u0026#34;Enter a and b\\n\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); do{ printf(\u0026#34;MENU\\n1.AND\\n2.OR\\n3.NOT \\n4.XOR\\n0.Exit\\n\u0026#34;); printf(\u0026#34;Enter choice: \u0026#34;); scanf(\u0026#34;%d\u0026#34;, \u0026amp;option); switch(option){ case 1: res = a \u0026amp; b; printf(\u0026#34;%d AND %d = %d\\n\u0026#34;, a, b, res); break; case 2: res = a | b; printf(\u0026#34;%d OR %d = %d\\n\u0026#34;, a, b, res); break; case 3: res = ~a; printf(\u0026#34;NOT of %d = %d\\n\u0026#34;, a, res); res = ~b; printf(\u0026#34;NOT of %d = %d\\n\u0026#34;, b, res); break; case 4: res = a ^ b; printf(\u0026#34;%d XOR %d = %d\\n\u0026#34;, a, b, res); break; default: break; } printf(\u0026#34;\\n\u0026#34;); }while(option); return 0; } Output:","title":"Bitwise operations in C"},{"content":"Code below swaps two numbers without using a third variable\n# include\u0026lt;stdio.h\u0026gt; int swap(int* a, int *b){ // swapping values using match trick \t*a = *a + *b; *b = *a - *b; *a = *a - *b; return 0; } int main(){ int a, b; printf(\u0026#34;Enter two numbers\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;a=%d, b=%d\u0026#34;, a, b); swap(\u0026amp;a, \u0026amp;b); printf(\u0026#34;a=%d, b=%d\u0026#34;, a, b); return 0; } Output:\nEnter two numbers 10 34 before swapping a=10, b=34 After swapping a=34, b=10 ","permalink":"https://zkhan.in/posts/c/swap-two-numbers-in-c/","summary":"Code below swaps two numbers without using a third variable\n# include\u0026lt;stdio.h\u0026gt; int swap(int* a, int *b){ // swapping values using match trick \t*a = *a + *b; *b = *a - *b; *a = *a - *b; return 0; } int main(){ int a, b; printf(\u0026#34;Enter two numbers\u0026#34;); scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;a=%d, b=%d\u0026#34;, a, b); swap(\u0026amp;a, \u0026amp;b); printf(\u0026#34;a=%d, b=%d\u0026#34;, a, b); return 0; } Output:\nEnter two numbers 10 34 before swapping a=10, b=34 After swapping a=34, b=10 ","title":"Swap Two Numbers in C"},{"content":"To add two numeric values in C\n#include\u0026lt;stdio.h\u0026gt; int main(){ float a, b; printf(\u0026#34;Enter two numbers\\n\u0026#34;); scanf(\u0026#34;%f %f\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;sum of %f and %f is %f\u0026#34;,a,b,a+b); return 0; } Output:\nEnter two numbers 12 34 sum of 12.000000 and 34.000000 is 46.000000 ","permalink":"https://zkhan.in/posts/c/add-two-numbers-in-c/","summary":"To add two numeric values in C\n#include\u0026lt;stdio.h\u0026gt; int main(){ float a, b; printf(\u0026#34;Enter two numbers\\n\u0026#34;); scanf(\u0026#34;%f %f\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;sum of %f and %f is %f\u0026#34;,a,b,a+b); return 0; } Output:\nEnter two numbers 12 34 sum of 12.000000 and 34.000000 is 46.000000 ","title":"Add Two Numbers in C"},{"content":"Following program will add two Integer numbers for you.\n// file Addition.java import java.io.*; class Addition{ public static void main(String args[]) throws IOException{ int a,b; BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); System.out.println(\u0026#34;Enter first integer\u0026#34;); a=Integer.parseInt(br.readLine()); System.out.println(\u0026#34;Enter second integer\u0026#34;); b=Integer.parseInt(br.readLine()); System.out.println(\u0026#34;Sum of two integers is: \u0026#34;+(a+b)); } } To run the above code navigate to the source code folder from cmd(Windows) or terminal(Linux) then type the following code to compile javac \u0026lt;filename\u0026gt;.java after sucessfully compiling, type java Addition to start the programe.\nThe above programme will output the following result\nEnter first integer 12 Enter second integer 123 Sum of two integers is: 135 ``` ","permalink":"https://zkhan.in/posts/java/add-two-numbers-in-java/","summary":"Following program will add two Integer numbers for you.\n// file Addition.java import java.io.*; class Addition{ public static void main(String args[]) throws IOException{ int a,b; BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); System.out.println(\u0026#34;Enter first integer\u0026#34;); a=Integer.parseInt(br.readLine()); System.out.println(\u0026#34;Enter second integer\u0026#34;); b=Integer.parseInt(br.readLine()); System.out.println(\u0026#34;Sum of two integers is: \u0026#34;+(a+b)); } } To run the above code navigate to the source code folder from cmd(Windows) or terminal(Linux) then type the following code to compile javac \u0026lt;filename\u0026gt;.java after sucessfully compiling, type java Addition to start the programe.","title":"Add Two Integers in Java"},{"content":"Moviepedia Films moviepediafilms.com is the \u0026lsquo;first social content discovery platform\u0026rsquo; where both filmmakers and their audience get rewarded for what they do best- create \u0026amp; curate.\nthe projects is a modern web application developed in Vue.js and Django hosted on DigitalOcean\ncheckout more about the project journey \u0026ldquo;Journey of a project Moviepedia\u0026rdquo;\n Phoenix - A School Management System This project was started as a help to a friend who was giving free classed to underprivileged kids in the neighbourhood. it is a web application that help keep track of student attendance, exam, results and generate some reports.\n","permalink":"https://zkhan.in/projects/","summary":"Projects","title":"Projects"}]